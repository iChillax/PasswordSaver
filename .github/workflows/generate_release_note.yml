name: Production - Build & Deploy AI Search Container app
on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Tag version to deploy (e.g., v1.0.0)'
        required: true
  
permissions:
  contents: read
  id-token: write

jobs:
  # ============================================
  # STAGE 0: VERSION CHECK
  # ============================================
  version-check:
    runs-on: self-hosted
    outputs:
      version: ${{ steps.version.outputs.version }}
      changelog_entry: ${{ steps.changelog.outputs.entry }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from tag or input
        id: version
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION"

      - name: Extract or generate changelog entry
        id: changelog
        run: |
          VERSION=${{ steps.version.outputs.version }}
          
          # Try to extract from CHANGELOG.md first
          if [ -f "CHANGELOG.md" ]; then
            CHANGELOG=$(sed -n "/## \[$VERSION\]/,/## \[/p" CHANGELOG.md | head -n -1)
            
            if [ -n "$CHANGELOG" ]; then
              echo "✓ Changelog entry found in CHANGELOG.md for version $VERSION"
              echo "entry<<EOF" >> $GITHUB_OUTPUT
              echo "$CHANGELOG" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # If no manual changelog, auto-generate from git commits
          echo "⚠️  No changelog entry found. Auto-generating from git commits..."
          
          # Get the previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || git rev-list --max-parents=0 HEAD)
          
          echo "Generating changelog from $PREV_TAG to HEAD"
          
          # Initialize changelog sections
          ADDED=""
          CHANGED=""
          FIXED=""
          SECURITY=""
          BREAKING=""
          OTHER=""
          
          # Parse commits since last tag
          while IFS= read -r commit; do
            # Extract commit message
            MSG=$(echo "$commit" | sed 's/^[a-f0-9]* //')
            
            # Categorize based on conventional commit format
            if [[ "$MSG" =~ ^feat(\(.*\))?!: ]]; then
              BREAKING="${BREAKING}- ${MSG#*: }\n"
            elif [[ "$MSG" =~ ^feat(\(.*\))?: ]]; then
              ADDED="${ADDED}- ${MSG#*: }\n"
            elif [[ "$MSG" =~ ^fix(\(.*\))?: ]]; then
              FIXED="${FIXED}- ${MSG#*: }\n"
            elif [[ "$MSG" =~ ^security(\(.*\))?: ]]; then
              SECURITY="${SECURITY}- ${MSG#*: }\n"
            elif [[ "$MSG" =~ ^(chore|docs|style|refactor|perf|test|build|ci)(\(.*\))?: ]]; then
              CHANGED="${CHANGED}- ${MSG#*: }\n"
            else
              OTHER="${OTHER}- ${MSG}\n"
            fi
          done < <(git log --oneline $PREV_TAG..HEAD)
          
          # Build changelog
          CHANGELOG="## [$VERSION] - $(date +%Y-%m-%d)\n\n"
          
          if [ -n "$BREAKING" ]; then
            CHANGELOG="${CHANGELOG}### ⚠️ BREAKING CHANGES\n${BREAKING}\n"
          fi
          
          if [ -n "$ADDED" ]; then
            CHANGELOG="${CHANGELOG}### Added\n${ADDED}\n"
          fi
          
          if [ -n "$CHANGED" ]; then
            CHANGELOG="${CHANGELOG}### Changed\n${CHANGED}\n"
          fi
          
          if [ -n "$FIXED" ]; then
            CHANGELOG="${CHANGELOG}### Fixed\n${FIXED}\n"
          fi
          
          if [ -n "$SECURITY" ]; then
            CHANGELOG="${CHANGELOG}### Security\n${SECURITY}\n"
          fi
          
          if [ -n "$OTHER" ]; then
            CHANGELOG="${CHANGELOG}### Other\n${OTHER}\n"
          fi
          
          # If no categorized commits, add a generic entry
          if [ -z "$ADDED" ] && [ -z "$CHANGED" ] && [ -z "$FIXED" ] && [ -z "$SECURITY" ] && [ -z "$OTHER" ] && [ -z "$BREAKING" ]; then
            CHANGELOG="${CHANGELOG}### Changed\n- Automated deployment\n"
          fi
          
          echo "✓ Auto-generated changelog from git commits"
          
          echo "entry<<EOF" >> $GITHUB_OUTPUT
          echo -e "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
  # ============================================
  # STAGE 0: GENERATE IMAGE TAG
  # ============================================
  generate-tag:
    runs-on: self-hosted
    needs: version-check
    outputs:
      tag: ${{ steps.vars.outputs.TAG }}
    steps:
      - name: Generate unique image tag
        id: vars
        run: |
          VERSION=${{ needs.version-check.outputs.version }}
          echo TAG="${VERSION}-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}"  >> $GITHUB_OUTPUT
  # ============================================
  # STAGE 1: UNIT TESTS
  # ============================================
  unit-tests:
    runs-on: self-hosted
    needs: version-check
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run unit tests
        run: echo "Passed"

  # ============================================
  # STAGE 2: INTEGRATION TESTS
  # ============================================
  integration-tests:
    runs-on: self-hosted
    needs: unit-tests
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run integration tests
        run: echo "Passed"

  # ============================================
  # STAGE 3: BUILD & SECURITY SCAN
  # ============================================
  build-and-scan:
    runs-on: self-hosted
    needs: [unit-tests, integration-tests, version-check, generate-tag]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build Docker image
        run: |
          TAG=${{ needs.generate-tag.outputs.tag }}
          IMAGE=${{ secrets.ACR_NAME }}.azurecr.io/housing_api_search:${{ needs.generate-tag.outputs.tag }}
          echo "Image: $IMAGE"

     

  # ============================================
  # STAGE 4: DEPLOY TO PRODUCTION
  # ============================================
  deploy:
    runs-on: self-hosted
    needs: [build-and-scan, version-check, generate-tag]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy to Container App
        run: |
          TAG=${{ needs.generate-tag.outputs.tag }}
          IMAGE=${{ secrets.ACR_NAME }}.azurecr.io/housing_api_search:$TAG
          
          echo "Deploying version: $VERSION"
          echo "Image: $IMAGE"

      - name: Create deployment annotation
        run: |
          VERSION=${{ needs.version-check.outputs.version }}
          COMMIT_SHA=${{ github.sha }}
          COMMIT_MSG=$(git log -1 --pretty=%B)
          
          echo "✓ Deployment successful"
          echo "Version: $VERSION"
          echo "Commit: $COMMIT_SHA"
          echo "Message: $COMMIT_MSG"

  # ============================================
  # STAGE 5: CREATE RELEASE & TAG
  # ============================================
  create-release:
    runs-on: ubuntu-latest
    needs: [deploy, version-check, generate-tag]
    if: success()
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Git tag
        run: |
          VERSION=${{ needs.version-check.outputs.version }}
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Check if tag exists
          if git rev-parse "$VERSION" >/dev/null 2>&1; then
            echo "Tag $VERSION already exists"
          else
            git tag -a "$VERSION" -m "Release version $VERSION"
            git push origin "$VERSION"
            echo "Created and pushed tag $VERSION"
          fi

      - name: Generate Release Notes
        id: release_notes
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ needs.version-check.outputs.version }}';
            
            // Get the previous tag
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 10
            });
            
            const previousTag = tags.find(tag => tag.name !== version)?.name || '';
            
            // Generate release notes using GitHub's API (uses release.yml config)
            const { data: releaseNotes } = await github.rest.repos.generateReleaseNotes({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: version,
              previous_tag_name: previousTag || undefined
            });
            
            // Save to output
            core.setOutput('notes', releaseNotes.body);
            core.setOutput('name', releaseNotes.name);
            
            return releaseNotes.body;

      - name: Update CHANGELOG.md
        run: |
          VERSION=${{ needs.version-check.outputs.version }}
          DATE=$(date +%Y-%m-%d)
          
          # Create CHANGELOG.md if it doesn't exist
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "All notable changes to this project will be documented in this file." >> CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          # Prepare the new changelog entry
          TEMP_FILE=$(mktemp)
          
          # Add the header
          echo "# Changelog" > "$TEMP_FILE"
          echo "" >> "$TEMP_FILE"
          echo "All notable changes to this project will be documented in this file." >> "$TEMP_FILE"
          echo "" >> "$TEMP_FILE"
          
          # Add the new release entry
          echo "## [$VERSION] - $DATE" >> "$TEMP_FILE"
          echo "" >> "$TEMP_FILE"
          echo "${{ steps.release_notes.outputs.notes }}" >> "$TEMP_FILE"
          echo "" >> "$TEMP_FILE"
          
          # Append existing changelog entries (skip the header)
          if [ -f CHANGELOG.md ]; then
            sed -n '/^## \[/,$p' CHANGELOG.md >> "$TEMP_FILE"
          fi
          
          # Replace the old changelog
          mv "$TEMP_FILE" CHANGELOG.md
          
          echo "✓ Updated CHANGELOG.md with version $VERSION"

      - name: Commit and Push CHANGELOG
        run: |
          VERSION=${{ needs.version-check.outputs.version }}
          
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Add the changelog
          git add CHANGELOG.md
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "docs: update CHANGELOG for $VERSION [skip ci]"
            git push origin HEAD:${{ github.ref_name }}
            echo "✓ Committed and pushed CHANGELOG.md"
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.version-check.outputs.version }}
          name: ${{ steps.release_notes.outputs.name }}
          body: ${{ steps.release_notes.outputs.notes }}
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
